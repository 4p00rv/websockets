---
layout: page
title:  "Code Samples"
permalink: demos/
---

<fieldset>
    <select id="demo-language">
        <option value="javascript">JavaScript</option>
        <option value="coffeescript">CoffeeScript</option>
        <option value="csharp">C#</option>
        <option value="go">Go</option>
        <option value="perl" hidden>Perl</option>
        <option value="java">Java</option>
        <option value="php" hidden>PHP</option>
        <option value="ruby">Ruby</options>
        <option value="python">Python</option>
        <option value="swift" hidden>Swift</option>
    </select>
</fieldset>

<p>Here is a code snippet that opens a websocket, and requests a stream of updates for the symbol "R_100".
On receipt of each message, it outputs a message.</p>

<div id="language-demos">

<pre data-language="javascript">var ws = new WebSocket(&#39;wss://www.binary.com/websockets/v2&#39;);

ws.onopen = function(evt) {
    ws.send(JSON.stringify({ticks:&#39;R_100&#39;}));
};

ws.onmessage = function(msg) {
   var data = JSON.parse(msg.data);
   console.log(&#39;ticks update: %o&#39;, data);
};
</pre>

<pre data-language="coffeescript">ws = new WebSocket('wss://www.binary.com/websockets/v2')

ws.onopen = (evt) ->
    ws.send JSON.stringify(ticks: 'R_100')

ws.onmessage = (msg) ->
    data = JSON.parse(msg.data)
    console.log 'ticks update: %o', data
</pre>

<pre data-language="csharp">class Program
{
    static async Task SendTicksRequest()
    {
        var ws = new ClientWebSocket();
        var uri = new Uri("wss://www.binary.com/websockets/v2");

        await ws.ConnectAsync(uri, CancellationToken.None);

        var reqAsBytes = Encoding.UTF8.GetBytes("{\"ticks\":\"R_100\"}");
        var ticksRequest = new ArraySegment&lt;byte>(reqAsBytes);

        await ws.SendAsync(ticksRequest, WebSocketMessageType.Text, true, CancellationToken.None);

        var buffer = new ArraySegment&lt;byte>(new byte[1024]);
        var result = await ws.ReceiveAsync(buffer, CancellationToken.None);

        string response = Encoding.UTF8.GetString(buffer.Array, 0, result.Count);
        Console.WriteLine(response);
    }

    static void Main(string[] args)
    {
        SendTicksRequest();
        Console.ReadLine();
    }
}
</pre>

<pre data-language="go">package main

import (
	"fmt"

	"golang.org/x/net/websocket"
)

var origin = "http://localhost/"
var url = "wss://ws.binary.com/websockets/v2?l=EN"

func main() {
	ws, _ := websocket.Dial(url, "", origin)

	message := []byte("{\"ticks\": \"R_100\"}")
	ws.Write(message)
	fmt.Printf("Send: %s\n", message)

	var msg = make([]byte, 512000)
	for {
		ws.Read(msg)
		fmt.Printf("Receive: %s\n", msg)
	}

}
</pre>

<pre data-language="java">package com.binary;

import java.net.URI;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.java_websocket.client.DefaultSSLWebSocketClientFactory;
import org.java_websocket.client.WebSocketClient;
import org.java_websocket.drafts.Draft;
import org.java_websocket.handshake.ServerHandshake;
import org.json.JSONObject;

public class BinaryWebSocketClient extends WebSocketClient {

	public BinaryWebSocketClient(URI serverUri, Draft draft) {
		super(serverUri, draft);

		// Create a trust manager that does not validate certificate chains
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {

			@Override
			public java.security.cert.X509Certificate[] getAcceptedIssuers() {
				return new java.security.cert.X509Certificate[]{};
			}

			@Override
			public void checkServerTrusted(java.security.cert.X509Certificate[] arg0,
					String arg1) throws java.security.cert.CertificateException {
			}

			@Override
			public void checkClientTrusted(java.security.cert.X509Certificate[] arg0,
					String arg1) throws java.security.cert.CertificateException {
			}
		}};

        // Install the all-trusting trust manager
        // We are ignoring SSL certificates
        try {
            SSLContext sc = SSLContext.getInstance("TLS");
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            setWebSocketFactory(new DefaultSSLWebSocketClientFactory(sc));
        } catch (Exception e) {
            e.printStackTrace();
        }

	}

	boolean isOpen = false;

	@Override
	public void onMessage(String message) {
		JSONObject obj = new JSONObject(message);
		String pong = obj.getString("ping");
		System.out.println("server reponse to ping : " + pong);
	}

	@Override
	public void onOpen(ServerHandshake handshake) {
		isOpen = true;
		System.out.println("opened connection");
	}

	@Override
	public void onClose(int code, String reason, boolean remote) {
		System.out.println("closed connection");
	}

	@Override
	public void onError(Exception ex) {
		ex.printStackTrace();
	}

}</pre>

<pre data-language="perl">TODO</pre>

<pre data-language="php">TODO</pre>

<pre data-language="ruby">gem install websocket-client-simple

require 'rubygems'
require 'websocket-client-simple'

ws = WebSocket::Client::Simple.connect 'wss://www.binary.com/websockets/v2'

ws.on :message do |msg|
  puts msg.data
end

ws.on :open do
  ws.send '{ticks:\'R_100\'}'
end

loop do
  ws.send STDIN.gets.strip
end
</pre>

<pre data-language="python">import websocket
import json

def on_open(ws):
    json_data = json.dumps({'ticks':'R_100'})
    ws.send(json_data)

def on_message(ws, message):
    print('ticks update: %s' % message)

if __name__ == "__main__":
    ws = websocket.WebSocketApp("wss://www.binary.com/websockets/v2", on_message = on_message, on_open = on_open)
    ws.run_forever()
</pre>

<pre data-language="swift">TODO</pre>

</div>
